****************** EXPRESSIONS AND OPERATORS ********************

Expression : valid unit of code that resolves to a value. 
side effects                      purely evaluate
x=7                               3 + 4

operators : binary and              unary operators 
              |                      |
              v                      v
      operand1 operator operand2     operator operand  ++x prefix OPERATORS (!, typeof etc)
                                     operand operator  x++ postfix operators  (++, -- only)


Name	                        Shorthand operator	                   Meaning
Assignment	                        x = f()	                        x = f()
Addition assignment	                x += f()	                    x = x + f()
Subtraction assignment	            x -= f()	                    x = x - f()
Multiplication assignment	        x *= f()	                    x = x * f()
Division assignment	                x /= f()	                    x = x / f()
Remainder assignment	            x %= f()	                    x = x % f()
Exponentiation assignment	        x **= f()	                    x = x ** f()
Left shift assignment	            x <<= f()	                    x = x << f()
Right shift assignment	            x >>= f()	                    x = x >> f()
Unsigned right shift assignment	    x >>>= f()	                    x = x >>> f()
Bitwise AND assignment	            x &= f()	                    x = x & f()
Bitwise XOR assignment	            x ^= f()	                    x = x ^ f()
Bitwise OR assignment	            x |= f()	                    x = x | f()
Logical AND assignment	            x &&= f()	                    x && (x = f())
Logical OR assignment	            x||= f()	                    x || (x = f())
Nullish coalescing assignment	    x ??= f()	                    x ?? (x = f())



Comparision operators:
compares its operands and returns a logical value based on whether the comparision is true. 

Operator	        Description	                                        Examples returning true
Equal (==)	        Returns true if the operands are equal.	            3 == var1
                                                                        "3" == var1
                                                                        3 == '3'
Not equal (!=)	    Returns true if the operands are not equal.	        var1 != 4
                                                                        var2 != "3"
Strict equal (===)	Returns true if the operands are equal and 
                    of the same type. See also Object.is 
                    and sameness in JS.	                                3 === var1
Strict not equal 
(!==)	            Returns true if the operands are of the same 
                    type but not equal, or are of different 
                    type.	                                            var1 !== "3"
                                                                        3 !== '3'
Greater than (>)	Returns true if the left operand is greater 
                    than the right operand.	                            var2 > var1
                                                                        "12" > 2
Greater than or 
equal (>=)	        Returns true if the left operand is greater     
                    than or equal to the right operand.	                var2 >= var1
                                                                        var1 >= 3
Less than (<)	    Returns true if the left operand is less 
                    than the right operand.	                            var1 < var2
                                                                        "2" < 12
Less than or equal 
(<=)	            Returns true if the left operand is less than
                    or equal to the right operand.	                    var1 <= var2
                                                                        var2 <= 5


Arithmetic operators
Bitwise operators
Logical operators
BigInt operators
String operators
Conditional operators
Comma operators
Unary operators
Relational operators   

*****************    STRICT MODE    ***************


Changes that strict mode make for normal js script:

    --≥Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes be made to run faster than identical code that's not strict mode.
    --≥Eliminates some JavaScript silent errors by changing them to throw errors.
    --≥Prohibits some syntax likely to be defined in future versions of ECMAScript.

This applies to entire script
doesn't apply to : block statements, eval code, functions, eventhandler attributes, setTimeout()


for functions : using with default parameter is an error             
for modules and classes: automatically in strict mode

Changes in strict mode:

          ( TO BE CONTINUED )

"use strict";
'use strict';





*************   JS this KEYWORD **************************


In js , this keyword(not a variable) refers to an object.


  IN                     REFERS TO 

Alone                    Global object
Object                   Object
Function                 Global object
Function(strict mode)    undefined
Event                    element that received the event
call()
apply()                  anyobject
bind()




****************** call()  ****************
****************** apply() ****************
****************** bind()  ****************


***************** Asynchronous js *****************

Aynchornous programming: technique that enables the program to start a potentially long running task , and still be able to  be responsive to other events while that task runs, rather than having to wait untill that task has finished. 

synchoronous functions : the browser effectively steps through the program one line at a time, in the order we wrote it. At each point, the browser waits for the line to finish its work before going on to the next line. As each line depends on the preceding lines.


problem with synchoronous function : the program becomes completely unresponsive, until one got completed.


what Asynchronous function do : 

        -->Start a long-running operation by calling a function.
        -->Have that function start the operation and return immediately, so that our program can still be responsive to other events.
        -->Notify us with the result of the operation when it eventually completes.





aynchronous js and event loop ( youtube ):

js is synchoronous single threaded language
1 call stack - 1 thing at a time (present at the js engine)
all code of js is executed at call stack (executes whatever comes inside of it) doesn't have timer.
js engine is inside the browser.
browser->js engine->call stack-->execution code.
  |        |
  |        |
  |      global object : window  (window.setTimeout and setTimeout are the same)
  |      web APIs [setTimeout(),DOM APIs, Console,Fetch,LocalStorage]
  |        | 
  |        |
  v        v
timer, url, local storage , bluetooth access and geolocation etc.

Global Execution Context is created and added into call stack
whenever function is invoked the Execution context


call back queue : function waits here to be executed. 

Event loops job is to constantly monitor the call stack and callback queue. If the call stack is empty and callback queue has a function , then it takes function and pushes to call stack.

fetch function goes and request api call ,
then callback function is executed.


we have micro task queue , but has higher priority. All the callback functions which comes through Promises and Mutation observer (which observes whether ther is mutation in dom tree or not ) will come under the MicroTaskQueue. 
All the other callback functions goes inside the callbackqueue[taskqueue].
Suppose a microtask produces another microtask STARVATION of the callbackqueue occurs. 








setTimeout( ) -> global function :

        -->setTimeout(funcitonRef , delay, param1, param2, ....., paramN)
        -->returnvalue for the this is timeoutID : used to identify the timer created by the call to setTimeout 
                                        never be used by a subsequent call to setTimeout() or setInterval()
        -->this value can be passed to clearTimeout() to cancel the timeout
        -->we cannot use this to "pause" before the next function in the function stack 



*doubt : The "this" problem (https://developer.mozilla.org/en-US/docs/Web/API/setTimeout

)     use wrapper function
      use bind*

    Reasons for delays longer than specified:
        --≥Nested timeouts
        --≥timeouts in inactive tabs
        --≥throtting of tracking scripts
        --≥late timeouts
        --≥deferral of timeouts during pageload
        --≥webextension background pages and timers
        --≥maximun delay value



setInterval( ) -> to call function repeatedly (every n miliseconds)

the syntax is same as setTimeout
in order to stop we should call clearInterval(timerId)

There are two ways of running something regularly 
  setInterval and nested setTimeout
  nested setTimeout is more flexible than setInterval because nested setTimeout allows to set the delay between the executions more precisely than setInterval

 let i = 1;
 setInterval(function() {
  func(i++);
    }, 100);


let i = 1;
setTimeout(function run() {
  func(i++);
  setTimeout(run, 100);
}, 100);

For setInterval the function stays in memory until clearInterval is called.

There’s a side effect. A function references the outer lexical environment, so, while it lives, outer variables live too. They may take much more memory than the function itself. So when we don’t need the scheduled function anymore, it’s better to cancel it, even if it’s very small.


Zero delay setTimeout:

setTimeout(() => alert("World"));
alert("Hello");

The first line “puts the call into calendar after 0ms”. But the scheduler will only “check the calendar” after the current script is complete, so "Hello" is first, and "World" – after it.

Zero delay is in fact not zero (in a browser):

The setTimeout call in it re-schedules itself with zero delay. Each call remembers the real time from the previous one in the times array. What do the real delays look like?

let start = Date.now();
let times = [];
setTimeout(function run() {
  times.push(Date.now() - start); // remember delay from the previous call
if (start + 100 < Date.now()) alert(times); // show the delays after 100ms
  else setTimeout(run); // else re-schedule
});
// an example of the output:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100

First timers run immediately (just as written in the spec), and then we see 9, 15, 20, 24.... The 4+ ms obligatory delay between invocations comes into play.
The similar thing happens if we use setInterval instead of setTimeout: setInterval(f) runs f few times with zero-delay, and afterwards with 4+ ms delay.
That limitation comes from ancient times and many scripts rely on it, so it exists for historical reasons.
For server-side JavaScript, that limitation does not exist, and there exist other ways to schedule an immediate asynchronous job, like setImmediate for Node.js. So this note is browser-specific.






















 